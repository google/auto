## Copyright 2014 Google LLC
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

## Template for each generated AutoValue_Foo class.
## This template uses the Apache Velocity Template Language (VTL).
## The variables ($pkg, $props, and so on) are defined by the fields of AutoValueTemplateVars.
##
## Comments, like this one, begin with ##. The comment text extends up to and including the newline
## character at the end of the line. So comments also serve to join a line to the next one.
## Velocity deletes a newline after a directive (#if, #foreach, #end etc) so ## is not needed there.
## That does mean that we sometimes need an extra blank line after such a directive.
##
## Post-processing will remove unwanted spaces and blank lines, but will not join two lines.
## It will also replace classes spelled as (e.g.) `java.util.Arrays`, with the backquotes, to
## use just Arrays if that class can be imported unambiguously, or java.util.Arrays if not.

## Get #equalsThatExpression($p) and #hashCodeExpression($p).
#parse("equalshashcode.vm")

#if (!$pkg.empty)
package $pkg;
#end

## The following line will be replaced by the required imports during post-processing.
`import`

${gwtCompatibleAnnotation}
#foreach ($a in $annotations)
$a
#end
#if (!$generated.empty)
@${generated}("com.google.auto.value.processor.AutoValueProcessor")
#else
// Generated by com.google.auto.value.processor.AutoValueProcessor
#end
${modifiers}class $subclass$formalTypes extends $origClass$actualTypes {

## Fields

#foreach ($p in $props)
  #foreach ($a in ${p.fieldAnnotations})

  ${a}##
  #end

  private final $p.type $p;
#end

## Constructor

#if ($isFinal && $builderTypeName != "")
  private ##
#end
  $subclass(
#foreach ($p in $props)

      ${p.nullableAnnotation}$p.type $p #if ($foreach.hasNext) , #end
#end ) {
#foreach ($p in $props)
  #if (!$p.kind.primitive && !$p.nullable && ($builderTypeName == "" || !$isFinal))
    ## We don't need a null check if the type is primitive or @Nullable. We also don't need it
    ## if there is a builder, since the build() method will check for us. However, if there is a
    ## builder but there are also extensions (!$isFinal) then we can't omit the null check because
    ## the constructor is called from the extension code.

    #if ($identifiers)

    if ($p == null) {
      throw new NullPointerException("Null $p.name");
    }
    #else
      ## Just throw NullPointerException with no message if it's null.
      ## The Object cast has no effect on the code but silences an ErrorProne warning.

    ((`java.lang.Object`) ${p}).getClass();
    #end

  #end

    this.$p = $p;
#end
  }

## Property getters

#foreach ($p in $props)

  #foreach ($a in ${p.methodAnnotations})

  ${a}##
  #end

  @`java.lang.Override`
  ${p.access}${p.type} ${p.getter}() {
    return $p;
  }

#end

#if ($toString)

  @`java.lang.Override`
  public `java.lang.String` toString() {
    return "#if ($identifiers)$simpleClassName#end{"

  #foreach ($p in $props)

        #if ($identifiers)+ "$p.name=" ##
        #end+ #if ($p.kind == "ARRAY") `java.util.Arrays`.toString($p) #else $p #end
        #if ($foreach.hasNext) + ", " #end

  #end

        + "}";
  }

#end

#if ($equals)

  @`java.lang.Override`
  public boolean equals($equalsParameterType o) {
    if (o == this) {
      return true;
    }
    if (o instanceof $origClass) {

  #if ($props.empty)

      return true;

  #else

      $origClass$wildcardTypes that = ($origClass$wildcardTypes) o;
      return ##
          #foreach ($p in $props)
          #equalsThatExpression ($p $subclass)##
            #if ($foreach.hasNext)

          && ##
            #end
          #end
          ;
  #end

    }
    return false;
  }

#end

#if ($hashCode)

  @`java.lang.Override`
  public int hashCode() {
    int h$ = 1;

  #foreach ($p in $props)

    h$ *= 1000003;
    h$ ^= #hashCodeExpression($p);

  #end

    return h$;
  }
#end

#if (!$serialVersionUID.empty)
  private static final long serialVersionUID = $serialVersionUID;
#end

#if ($builderTypeName != "")

  #foreach ($m in $toBuilderMethods)

  @`java.lang.Override`
  ${m.access}${builderTypeName}${builderActualTypes} ${m.name}() {
    return new Builder${builderActualTypes}(this);
  }

  #end

  ## BUILDER CLASS

  #foreach ($a in $builderAnnotations)

  $a##
  #end

  static #if ($isFinal) final #end class Builder${builderFormalTypes} ##
  #if ($builderIsInterface) implements #else extends #end
      ${builderTypeName}${builderActualTypes} {

  #foreach ($p in $props)

    #if ($p.kind.primitive)

    private $types.boxedClass($p.typeMirror).simpleName $p;

    #else

      #if ($builderPropertyBuilders[$p.name])
      ## If you have ImmutableList.Builder<String> stringsBuilder() then we define two fields:
      ## private ImmutableList.Builder<String> stringsBuilder$;
      ## private ImmutableList<String> strings;

    private ${builderPropertyBuilders[$p.name].builderType} ##
        ${builderPropertyBuilders[$p.name].name};

      #end

    private $p.type $p #if ($p.optional && !$p.nullable) = $p.optional.empty #end ;

    #end
  #end

    Builder() {
    }

  #if (!$toBuilderMethods.empty)

    private Builder(${origClass}${actualTypes} source) {

    #foreach ($p in $props)

      this.$p = source.${p.getter}();

    #end

    }

  #end

  #foreach ($p in $props)

    ## The following is either null or an instance of PropertyBuilderClassifier.PropertyBuilder
    #set ($propertyBuilder = $builderPropertyBuilders[$p.name])

    ## Setter and/or property builder

    #foreach ($setter in $builderSetters[$p.name])

    @`java.lang.Override`
    ${setter.access}${builderTypeName}${builderActualTypes} ##
        ${setter.name}(${setter.nullableAnnotation}$setter.parameterType $p) {

      ## Omit null check for primitive, or @Nullable, or if we are going to be calling a copy method
      ## such as Optional.of, which will have its own null check if appropriate.
      #if (!$setter.primitiveParameter && !$p.nullable && ${setter.copy($p)} == $p)

        #if ($identifiers)

      if ($p == null) {
        throw new NullPointerException("Null $p.name");
      }
        #else
          ## Just throw NullPointerException with no message if it's null.
          ## The Object cast has no effect on the code but silences an ErrorProne warning.

      ((`java.lang.Object`) ${p}).getClass();
        #end

      #end

      #if ($propertyBuilder)

      if (${propertyBuilder.name} != null) {
        throw new IllegalStateException(#if ($identifiers)"Cannot set $p after calling ${p.name}Builder()"#end);
      }

      #end

      this.$p = ${setter.copy($p)};
      return this;
    }

    #end

    #if ($propertyBuilder)

    @`java.lang.Override`
    ${propertyBuilder.access}$propertyBuilder.builderType ${p.name}Builder(${propertyBuilder.propertyBuilderMethodParameters}) {
      if (${propertyBuilder.name} == null) {

        ## This is the first time someone has asked for the builder. If the property it sets already
        ## has a value (because it came from a toBuilder() call on the AutoValue class, or because
        ## there is also a setter for this property) then we copy that value into the builder.
        ## Otherwise the builder starts out empty.
        ## If we have neither a setter nor a toBuilder() method, then the builder always starts
        ## off empty.

        #if ($builderSetters[$p.name].empty && $toBuilderMethods.empty)

        ${propertyBuilder.name} = ${propertyBuilder.initializer};

        #else

        if ($p == null) {
          ${propertyBuilder.name} = ${propertyBuilder.initializer};
        } else {

          #if (${propertyBuilder.builtToBuilder})

          ${propertyBuilder.name} = ${p}.${propertyBuilder.builtToBuilder}();

          #else

          ${propertyBuilder.name} = ${propertyBuilder.initializer};
          ${propertyBuilder.name}.${propertyBuilder.copyAll}($p);

          #end

          $p = null;
        }

        #end

      }
      return $propertyBuilder.name;
    }

    #end

    ## Getter

    #if ($builderGetters[$p.name])

    @`java.lang.Override`
    ${p.nullableAnnotation}${builderGetters[$p.name].access}$builderGetters[$p.name].type ${p.getter}() {
      #if ($builderGetters[$p.name].optional)

      if ($p == null) {
        return $builderGetters[$p.name].optional.empty;
      } else {
        return ${builderGetters[$p.name].optional.rawType}.of($p);
      }

      #else
        #if ($builderRequiredProperties.contains($p))

      if ($p == null) {
        throw new IllegalStateException(#if ($identifiers)"Property \"$p.name\" has not been set"#end);
      }

        #end

        #if ($propertyBuilder)

      if (${propertyBuilder.name} != null) {
        return ${propertyBuilder.name}.build();
      }
      if ($p == null) {
        ${propertyBuilder.beforeInitDefault}
        $p = ${propertyBuilder.initDefault};
      }

        #end

      return $p;

      #end

    }

    #end
  #end

    @`java.lang.Override`
    ${buildMethod.get().access}${origClass}${actualTypes} ${buildMethod.get().name}() {

  #foreach ($p in $props)
    #set ($propertyBuilder = $builderPropertyBuilders[$p.name])
    #if ($propertyBuilder)

      if (${propertyBuilder.name} != null) {
        this.$p = ${propertyBuilder.name}.build();
      } else if (this.$p == null) {
        ${propertyBuilder.beforeInitDefault}
        this.$p = ${propertyBuilder.initDefault};
      }

    #end
  #end

  #if (!$builderRequiredProperties.empty)
    #if ($identifiers)  ## build a friendly message showing all missing properties

      `java.lang.String` missing = "";

      #foreach ($p in $builderRequiredProperties)

      if (this.$p == null) {
        missing += " $p.name";
      }

      #end

      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }

    #else  ## just throw an exception if anything is missing

      if (#foreach ($p in $builderRequiredProperties)##
          this.$p == null##
          #if ($foreach.hasNext) || #end
          #end) {
        throw new IllegalStateException();
      }
    #end
  #end

      return new ${finalSubclass}${actualTypes}(
  #foreach ($p in $props)

          this.$p #if ($foreach.hasNext) , #end
  #end );
    }
  }
#end

}
