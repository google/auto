package com.google.auto.value.processor;

final class AutoValueVm {

    static final String VM = "## Template for each generated AutoValue_Foo class.\n"
            + "## This template uses the Apache Velocity Template Language (VTL).\n"
            + "## The variables ($pkg, $props, and so on) are defined by the fields of AutoValueTemplateVars.\n"
            + "##\n"
            + "## Comments, like this one, begin with ##. The comment text extends up to and including the newline\n"
            + "## character at the end of the line. So comments also serve to join a line to the next one.\n"
            + "## Velocity deletes a newline after a directive (#if, #foreach, #end etc) so ## is not needed there.\n"
            + "## That does mean that we sometimes need an extra blank line after such a directive.\n"
            + "##\n"
            + "## A post-processing step will remove unwanted spaces and blank lines, but will not join two lines.\n"
            + "\n"
            + "#if (!$pkg.empty)\n"
            + "package $pkg;\n"
            + "#end\n"
            + "\n"
            + "#foreach ($i in $imports)\n"
            + "import $i;\n"
            + "#end\n"
            + "\n"
            + "${gwtCompatibleAnnotation}\n"
            + "#foreach ($a in $annotations)\n"
            + "$a\n"
            + "#end\n"
            + "#if ($generated != \"\")\n"
            + "@${generated}(\"com.google.auto.value.processor.AutoValueProcessor\")\n"
            + "#end\n"
            + "#if ($isFinal) final #else abstract #end class $subclass$formalTypes extends $origClass$actualTypes {\n"
            + "\n"
            + "## Fields\n"
            + "\n"
            + "#foreach ($p in $props)\n"
            + "  private final $p.type $p;\n"
            + "#end\n"
            + "\n"
            + "## Constructor\n"
            + "\n"
            + "#if ($isFinal && $builderTypeName != \"\")\n"
            + "  private ##\n"
            + "#end\n"
            + "  $subclass(\n"
            + "#foreach ($p in $props)\n"
            + "\n"
            + "      ${p.nullableAnnotation}$p.type $p #if ($foreach.hasNext) , #end\n"
            + "#end ) {\n"
            + "#foreach ($p in $props)\n"
            + "  #if (!$p.kind.primitive && !$p.nullable && ($builderTypeName == \"\" || !$isFinal))\n"
            + "    ## We don't need a null check if the type is primitive or @Nullable. We also don't need it\n"
            + "    ## if there is a builder, since the build() method will check for us. However, if there is a\n"
            + "    ## builder but there are also extensions (!$isFinal) then we can't omit the null check because\n"
            + "    ## the constructor is called from the extension code.\n"
            + "\n"
            + "    if ($p == null) {\n"
            + "      throw new NullPointerException(\"Null $p.name\");\n"
            + "    }\n"
            + "\n"
            + "  #end\n"
            + "\n"
            + "    this.$p = $p;\n"
            + "#end\n"
            + "  }\n"
            + "\n"
            + "## Property getters\n"
            + "\n"
            + "#foreach ($p in $props)\n"
            + "\n"
            + "  #foreach ($a in ${p.annotations})\n"
            + "\n"
            + "  ${a}##\n"
            + "  #end\n"
            + "\n"
            + "  @Override\n"
            + "  ${p.access}${p.type} ${p.getter}() {\n"
            + "    return $p;\n"
            + "  }\n"
            + "\n"
            + "#end\n"
            + "\n"
            + "#if ($toString)\n"
            + "\n"
            + "  @Override\n"
            + "  public String toString() {\n"
            + "    return \"$simpleClassName{\"\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "\n"
            + "        + \"$p.name=\" ##\n"
            + "        + #if ($p.kind == \"ARRAY\") ${arrays}.toString($p) #else $p #end\n"
            + "        #if ($foreach.hasNext) + \", \" #end\n"
            + "\n"
            + "  #end\n"
            + "\n"
            + "        + \"}\";\n"
            + "  }\n"
            + "\n"
            + "#end\n"
            + "\n"
            + "#if ($equals)\n"
            + "  #macro (equalsThatExpression $p)\n"
            + "    #if ($p.kind == \"FLOAT\")\n"
            + "      Float.floatToIntBits(this.$p) == Float.floatToIntBits(that.${p.getter}()) ##\n"
            + "    #elseif ($p.kind == \"DOUBLE\")\n"
            + "      Double.doubleToLongBits(this.$p) == Double.doubleToLongBits(that.${p.getter}()) ##\n"
            + "    #elseif ($p.kind.primitive)\n"
            + "      this.$p == that.${p.getter}() ##\n"
            + "    #elseif ($p.kind == \"ARRAY\")\n"
            + "      ${arrays}.equals(this.$p, ##\n"
            + "          (that instanceof $subclass) ? (($subclass) that).$p : that.${p.getter}()) ##\n"
            + "    #else\n"
            + "      #if ($p.nullable) (this.$p == null) ? (that.${p.getter}() == null) : #end ##\n"
            + "          this.${p}.equals(that.${p.getter}()) ##\n"
            + "    #end\n"
            + "  #end\n"
            + "\n"
            + "  @Override\n"
            + "  public boolean equals(Object o) {\n"
            + "    if (o == this) {\n"
            + "      return true;\n"
            + "    }\n"
            + "    if (o instanceof $origClass) {\n"
            + "\n"
            + "  #if ($props.empty)\n"
            + "\n"
            + "      return true;\n"
            + "\n"
            + "  #else\n"
            + "\n"
            + "      $origClass$wildcardTypes that = ($origClass$wildcardTypes) o;\n"
            + "      return ##\n"
            + "           #foreach ($p in $props)\n"
            + "           (#equalsThatExpression ($p))##\n"
            + "             #if ($foreach.hasNext)\n"
            + "\n"
            + "           && ##\n"
            + "             #end\n"
            + "           #end\n"
            + "           ;\n"
            + "  #end\n"
            + "\n"
            + "    }\n"
            + "    return false;\n"
            + "  }\n"
            + "\n"
            + "#end\n"
            + "\n"
            + "#if ($hashCode)\n"
            + "  #macro (hashCodeExpression $p)\n"
            + "    #if ($p.kind == \"BYTE\" || $p.kind == \"SHORT\" || $p.kind == \"CHAR\" || $p.kind == \"INT\")\n"
            + "      this.$p ##\n"
            + "    #elseif ($p.kind == \"LONG\")\n"
            + "      (this.$p >>> 32) ^ this.$p ##\n"
            + "    #elseif ($p.kind == \"FLOAT\")\n"
            + "      Float.floatToIntBits(this.$p) ##\n"
            + "    #elseif ($p.kind == \"DOUBLE\")\n"
            + "      (Double.doubleToLongBits(this.$p) >>> 32) ^ Double.doubleToLongBits(this.$p) ##\n"
            + "    #elseif ($p.kind == \"BOOLEAN\")\n"
            + "      this.$p ? 1231 : 1237 ##\n"
            + "    #elseif ($p.kind == \"ARRAY\")\n"
            + "      ${arrays}.hashCode(this.$p) ##\n"
            + "    #else\n"
            + "      #if ($p.nullable) ($p == null) ? 0 : #end this.${p}.hashCode() ##\n"
            + "    #end\n"
            + "  #end\n"
            + "\n"
            + "  @Override\n"
            + "  public int hashCode() {\n"
            + "    int h = 1;\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "\n"
            + "    h *= 1000003;\n"
            + "    h ^= #hashCodeExpression($p);\n"
            + "\n"
            + "  #end\n"
            + "\n"
            + "    return h;\n"
            + "  }\n"
            + "#end\n"
            + "\n"
            + "#if (!$serialVersionUID.empty)\n"
            + "  private static final long serialVersionUID = $serialVersionUID;\n"
            + "#end\n"
            + "\n"
            + "#if ($builderTypeName != \"\")\n"
            + "\n"
            + "  #foreach ($m in $toBuilderMethods)\n"
            + "\n"
            + "  @Override\n"
            + "  public ${builderTypeName}${builderActualTypes} ${m}() {\n"
            + "    return new Builder${builderActualTypes}(this);\n"
            + "  }\n"
            + "\n"
            + "  #end\n"
            + "\n"
            + "  static final class Builder${builderFormalTypes} ##\n"
            + "  #if ($builderIsInterface) implements #else extends #end\n"
            + "      ${builderTypeName}${builderActualTypes} {\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "\n"
            + "    #if ($p.kind.primitive)\n"
            + "\n"
            + "    private $types.boxedClass($p.typeMirror).simpleName $p;\n"
            + "\n"
            + "    #else\n"
            + "\n"
            + "      #if ($builderPropertyBuilders[$p.name])\n"
            + "      ## If you have ImmutableList.Builder<String> stringsBuilder() then we define two fields:\n"
            + "      ## private ImmutableList.Builder<String> stringsBuilder$;\n"
            + "      ## private ImmutableList<String> strings;\n"
            + "\n"
            + "    private ${builderPropertyBuilders[$p.name].builderType} ##\n"
            + "        ${builderPropertyBuilders[$p.name].name};\n"
            + "\n"
            + "      #end\n"
            + "\n"
            + "    private $p.type $p #if ($p.optional && !$p.nullable) = $p.optional.empty #end ;\n"
            + "\n"
            + "    #end\n"
            + "  #end\n"
            + "\n"
            + "    Builder() {\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "    #if ($builderPropertyBuilders[$p.name])\n"
            + "\n"
            + "      this.$p = ${builderPropertyBuilders[$p.name].empty};\n"
            + "\n"
            + "    #end\n"
            + "  #end\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    Builder(${origClass}${actualTypes} source) {\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "\n"
            + "      this.$p = source.${p.getter}();\n"
            + "\n"
            + "  #end\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "\n"
            + "    ## The following is either null or an instance of BuilderSpec.PropertyBuilder\n"
            + "    #set ($propertyBuilder = $builderPropertyBuilders[$p.name])\n"
            + "\n"
            + "    ## Setter and/or property builder\n"
            + "\n"
            + "    #foreach ($setter in $builderSetters[$p.name])\n"
            + "\n"
            + "    @Override\n"
            + "    public ${builderTypeName}${builderActualTypes} ##\n"
            + "        ${setter.name}(${p.nullableAnnotation}$setter.parameterType $p) {\n"
            + "\n"
            + "      #if ($propertyBuilder)\n"
            + "\n"
            + "      if (${propertyBuilder.name} != null) {\n"
            + "        throw new IllegalStateException(\"Cannot set $p after calling ${p.name}Builder()\");\n"
            + "      }\n"
            + "\n"
            + "      #end\n"
            + "\n"
            + "      this.$p = ${setter.copy($p)};\n"
            + "      return this;\n"
            + "    }\n"
            + "\n"
            + "    #end\n"
            + "\n"
            + "    #if ($propertyBuilder)\n"
            + "\n"
            + "    @Override\n"
            + "    public $propertyBuilder.builderType ${p.name}Builder() {\n"
            + "      if (${propertyBuilder.name} == null) {\n"
            + "        ${propertyBuilder.name} = ${propertyBuilder.initializer};\n"
            + "        ${propertyBuilder.name}.${propertyBuilder.copyAll}($p);\n"
            + "        $p = null;\n"
            + "      }\n"
            + "      return $propertyBuilder.name;\n"
            + "    }\n"
            + "\n"
            + "    #end\n"
            + "\n"
            + "    ## Getter\n"
            + "\n"
            + "    #if ($builderGetters[$p.name])\n"
            + "\n"
            + "    @Override\n"
            + "    ${p.nullableAnnotation}public $builderGetters[$p.name].type ${p.getter}() {\n"
            + "      #if ($builderGetters[$p.name].optional)\n"
            + "\n"
            + "      if ($p == null) {\n"
            + "        return $builderGetters[$p.name].optional.empty;\n"
            + "      } else {\n"
            + "        return ${builderGetters[$p.name].optional.rawType}.of($p);\n"
            + "      }\n"
            + "\n"
            + "      #else\n"
            + "        #if ($builderRequiredProperties.contains($p))\n"
            + "\n"
            + "      if ($p == null) {\n"
            + "        throw new IllegalStateException(\"Property \\\"$p.name\\\" has not been set\");\n"
            + "      }\n"
            + "\n"
            + "        #end\n"
            + "\n"
            + "        #if ($builderPropertyBuilders[$p.name])\n"
            + "\n"
            + "      if (${propertyBuilder.name} != null) {\n"
            + "        return ${propertyBuilder.name}.build();\n"
            + "      }\n"
            + "\n"
            + "        #end\n"
            + "\n"
            + "      return $p;\n"
            + "\n"
            + "      #end\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    #end\n"
            + "  #end\n"
            + "\n"
            + "    @Override\n"
            + "    public ${origClass}${actualTypes} ${buildMethodName}() {\n"
            + "\n"
            + "  #foreach ($p in $props)\n"
            + "    #if ($builderPropertyBuilders[$p.name])\n"
            + "\n"
            + "      if (${builderPropertyBuilders[$p.name].name} != null) {\n"
            + "        $p = ${builderPropertyBuilders[$p.name].name}.build();\n"
            + "      }\n"
            + "\n"
            + "    #end\n"
            + "  #end\n"
            + "\n"
            + "  #if (!$builderRequiredProperties.empty)\n"
            + "\n"
            + "      String missing = \"\";\n"
            + "\n"
            + "    #foreach ($p in $builderRequiredProperties)\n"
            + "\n"
            + "      if ($p == null) {\n"
            + "        missing += \" $p.name\";\n"
            + "      }\n"
            + "\n"
            + "    #end\n"
            + "\n"
            + "      if (!missing.isEmpty()) {\n"
            + "        throw new IllegalStateException(\"Missing required properties:\" + missing);\n"
            + "      }\n"
            + "  #end\n"
            + "\n"
            + "      return new ${finalSubclass}${actualTypes}(\n"
            + "  #foreach ($p in $props)\n"
            + "\n"
            + "          this.$p #if ($foreach.hasNext) , #end\n"
            + "  #end );\n"
            + "    }\n"
            + "  }\n"
            + "#end\n"
            + "\n"
            + "}\n";

    private AutoValueVm() {

    }

}
