## Copyright 2018 Google LLC
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

## Template for each generated AutoOneOf_Foo class.
## This template uses the Apache Velocity Template Language (VTL).
## The variables ($pkg, $props, and so on) are defined by the fields of AutoOneOfTemplateVars.
##
## Comments, like this one, begin with ##. The comment text extends up to and including the newline
## character at the end of the line. So comments also serve to join a line to the next one.
## Velocity deletes a newline after a directive (#if, #foreach, #end etc) so ## is not needed there.
## That does mean that we sometimes need an extra blank line after such a directive.
##
## Post-processing will remove unwanted spaces and blank lines, but will not join two lines.
## It will also replace classes spelled as (e.g.) `java.util.Arrays`, with the backquotes, to
## use just Arrays if that class can be imported unambiguously, or java.util.Arrays if not.

## Get #equalsThatExpression($p) and #hashCodeExpression($p).
#parse("equalshashcode.vm")

#if (!$pkg.empty)
package $pkg;
#end

## The following line will be replaced by the required imports during post-processing.
`import`

#if ($generated.empty)
// Generated by com.google.auto.value.processor.AutoOneOfProcessor
#else
@${generated}("com.google.auto.value.processor.AutoOneOfProcessor")
#end
final class $generatedClass {
  private ${generatedClass}() {} // There are no instances of this type.

## Factory methods.
#foreach ($p in $props)

  #if ($p.type == "void")
    #if ($wildcardTypes == "")

  static $origClass $p() {
    return Impl_${p}.INSTANCE;
  }

    #else

  @SuppressWarnings("unchecked") // type parameters are unused in void instances
  static $formalTypes $origClass$actualTypes $p() {
    return ($origClass$actualTypes) Impl_${p}.INSTANCE;
  }

    #end

  #else

  ## If the @AutoOneOf type is TaskResult<V extends Serializable>, then we might have here:
  ## static <V extends Serializable> TaskResult<V> value(V value) {
  ##   return new Impl_value<V>(value);
  ## }
  ## The parameter type might be something else (Throwable for example), but we will still
  ## want <V extends Serializable> TaskResult<V>.

  static $formalTypes $origClass$actualTypes $p($p.type $p) {

    #if (!$p.kind.primitive)

    if ($p == null) {
      throw new NullPointerException();
    }

    #end

    return new Impl_$p$actualTypes($p);
  }

  #end

#end

  #foreach ($a in $annotations)

  $a

  #end

  // Parent class that each implementation will inherit from.
  private abstract static class Parent_$formalTypes extends $origClass$actualTypes {

#foreach ($p in $props)

    @Override
    $p.access $p.type ${p.getter}() {
      throw new UnsupportedOperationException(${kindGetter}().toString());
    }

#end

  }

#foreach ($p in $props)


  #foreach ($a in $annotations)

  $a

  #end

  // Implementation when the contained property is "${p}".
  private static final class Impl_$p$formalTypes extends Parent_$actualTypes {

  #if ($p.type == "void")

    // There is only one instance of this class.
    static final Impl_$p$wildcardTypes INSTANCE = new ##
      #if ($wildcardTypes == "") Impl_$p() #else Impl_$p<>() #end;

    private Impl_$p() {}

    @Override
    public void ${p.getter}() {}

    #if ($serializable)

    private Object readResolve() {
      return INSTANCE;
    }

    #end

    #if ($toString)

    @Override
    public String toString() {
      return "${simpleClassName}{$p.name}";
    }

    #end

    ## The implementations of equals and hashCode are equivalent to the ones
    ## we inherit from Object. We only need to define them if they're redeclared
    ## as abstract in an ancestor class. But currently we define them always.

    #if ($equals)

    @Override
    public boolean equals($equalsParameterType x) {
      return x == this;
    }

    #end

    #if ($hashCode)

    @Override
    public int hashCode() {
      return System.identityHashCode(this);
    }

    #end

  #else

    private final $p.type $p;

    Impl_$p($p.type $p) {
      this.$p = $p;
    }

    @Override
    public $p.type ${p.getter}() {
      return $p;
    }

    #if ($toString)

    @Override
    public String toString() {
      return "${simpleClassName}{$p.name=" ##
          + #if ($p.kind == "ARRAY") `java.util.Arrays`.toString(this.$p) #else this.$p #end
          + "}";
    }

    #end

    #if ($equals)

    @Override
    public boolean equals($equalsParameterType x) {
      if (x instanceof $origClass) {
        $origClass$wildcardTypes that = ($origClass$wildcardTypes) x;
        return this.${kindGetter}() == that.${kindGetter}()
            && #equalsThatExpression($p "Impl_$p");
      } else {
        return false;
      }
    }

    #end

    #if ($hashCode)

    @Override
    public int hashCode() {
      return #hashCodeExpression($p);
    }

    #end

  #end

    @Override
    public $kindType ${kindGetter}() {
      return ${kindType}.$propertyToKind[$p.name];
    }

  }

#end

}
