## Copyright (C) 2018 Google, Inc.
##
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

## Template for each generated AutoOneOf_Foo class.
## This template uses the Apache Velocity Template Language (VTL).
## The variables ($pkg, $props, and so on) are defined by the fields of AutoOneOfTemplateVars.
##
## Comments, like this one, begin with ##. The comment text extends up to and including the newline
## character at the end of the line. So comments also serve to join a line to the next one.
## Velocity deletes a newline after a directive (#if, #foreach, #end etc) so ## is not needed there.
## That does mean that we sometimes need an extra blank line after such a directive.
##
## Post-processing will remove unwanted spaces and blank lines, but will not join two lines.
## It will also replace classes spelled as (e.g.) `java.util.Arrays`, with the backquotes, to
## use just Arrays if that class can be imported unambiguously, or java.util.Arrays if not.

## Get #equalsThatExpression($p) and #hashCodeExpression($p).
#parse("equalshashcode.vm")

#if (!$pkg.empty)
package $pkg;
#end

## The following line will be replaced by the required imports during post-processing.
`import`

#if ($generated.empty)
// Generated by com.google.auto.value.processor.AutoOneOfProcessor
#else
@${generated}("com.google.auto.value.processor.AutoOneOfProcessor")
#end
final class $generatedClass {
  private ${generatedClass}() {} // There are no instances of this type.

## Factory methods.
#foreach ($p in $props)

  ## If the @AutoOneOf type is TaskResult<V extends Serializable>, then we might have here:
  ## static <V extends Serializable> TaskResult<V> value(V value) {
  ##   return new Impl_value<V>(value);
  ## }
  ## The parameter type might be something else (Throwable for example), but we will still
  ## want <V extends Serializable> TaskResult<V>.

  static $formalTypes $origClass$actualTypes $p($p.type $p) {

  #if (!$p.kind.primitive)

    ${p}.getClass();  // NullPointerException if null

  #end

    return new Impl_$p$actualTypes($p);
  }

#end

  // Parent class that each implementation will inherit from.
  private abstract static class Parent_$formalTypes extends $origClass$actualTypes {

#foreach ($p in $props)

    @Override
    $p.access $p.type ${p.getter}() {
      throw new UnsupportedOperationException(${kindGetter}().toString());
    }

#end

  }

#foreach ($p in $props)

  // Implementation when the contained property is "${p}".
  private static final class Impl_$p$formalTypes extends Parent_$actualTypes {
    private final $p.type $p;

    Impl_$p($p.type $p) {
      this.$p = $p;
    }

    @Override
    public $kindType ${kindGetter}() {
      return ${kindType}.$propertyToKind[$p.name];
    }

    @Override
    public $p.type ${p.getter}() {
      return $p;
    }

  #if ($toString)

    @Override
    public String toString() {
      return "${simpleClassName}{$p.name=" + this.$p + "}";
    }

  #end

  #if ($equals)

    @Override
    public boolean equals($equalsParameterType x) {
      if (x instanceof $origClass) {
        $origClass$wildcardTypes that = ($origClass$wildcardTypes) x;
        return this.${kindGetter}() == that.${kindGetter}()
            && #equalsThatExpression($p);
      } else {
        return false;
      }
    }

  #end

  #if ($hashCode)

    @Override
    public int hashCode() {
      return #hashCodeExpression($p);
    }

  #end

  }

#end

}
